#!/bin/bash

# ==============================================================================
# PWNENV - Gestionnaire d'environnement et de projets de Pwn
# ==============================================================================

# --- Configuration Globale ---
CHALLENGES_DIR=~/challenges;
VENV_DIR="$CHALLENGES_DIR/.pwnenv";
TOOLS_DIR="$VENV_DIR/tools";
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)";
INIT_SCRIPT_PATH="$TOOLS_DIR/init_challenge.py"
API_SCRIPT_PATH="$TOOLS_DIR/pwnlib_api.py"

# --- Gestion des couleurs ---
GREEN='\033[0;32m';
YELLOW='\033[1;33m';
RED='\033[0;31m';
CYAN='\033[0;36m';
BOLD='\033[1m';
NC='\033[0m';

PWNENV_VERSION="3.1.3";

function show_help {
    echo -e "${BOLD}${GREEN}PwnEnv - v${PWNENV_VERSION} - Just make Pwn${NC}"
    echo "Usage: pwnenv <commande> [arguments]"
    echo -e "\n  ${CYAN}init${NC} <nom_projet> [source] [options_ssh]   Initialise un challenge."
    echo -e "  ${CYAN}go${NC}   <nom_projet>                          Se déplace dans un projet et active l'environnement."
    echo -e "\n${BOLD}SOURCES POUR 'init' :${NC}"
    echo -e "  ${YELLOW}--local${NC} /chemin/binaire      Utilise un binaire local."
    echo -e "  ${YELLOW}--ssh${NC} user@host:/path/bin   Référence un binaire distant."
    echo -e "  (aucune source)                 Crée un projet vide."
    echo -e "\n${BOLD}OPTIONS SSH POUR 'init' (sauvegardées pour l'exploit) :${NC}"
    echo -e "  ${YELLOW}--ssh-host${NC} <host>             Nom d'hôte pour l'exécution distante."
    echo -e "  ${YELLOW}--ssh-user${NC} <user>             Utilisateur pour l'exécution distante."
    echo -e "  ${YELLOW}--ssh-port${NC} <port>             Port SSH."
    echo -e "  ${YELLOW}--ssh-pass${NC} <mdp>              Mot de passe SSH."
    echo -e "  ${YELLOW}--libc${NC} <chemin|version>       Spécifie la libc à utiliser."
}

# Crée l'environnement et déploie les scripts la première fois
function self_setup {
    if [ -d "$VENV_DIR" ]; then
        return 0 # Déjà configuré
    fi

    echo -e "${YELLOW}Première utilisation. Configuration de l'environnement global...${NC}"
    sleep 0.5
    mkdir -p "$TOOLS_DIR"

    # Copie obligatoire depuis tools/ (ou PWNENV_TOOLS_PATH) sans fallback
    PWNENV_TOOLS_PATH_DEFAULT="$SCRIPT_DIR/tools"
    PWNENV_TOOLS_PATH="${PWNENV_TOOLS_PATH:-$PWNENV_TOOLS_PATH_DEFAULT}"
    if [ ! -f "$PWNENV_TOOLS_PATH/pwnlib_api.py" ] || [ ! -f "$PWNENV_TOOLS_PATH/init_challenge.py" ]; then
        echo -e "${RED}Erreur: Scripts introuvables dans '$PWNENV_TOOLS_PATH'.${NC}"
        exit 1
    fi
    cp "$PWNENV_TOOLS_PATH/pwnlib_api.py" "$API_SCRIPT_PATH"
    cp "$PWNENV_TOOLS_PATH/init_challenge.py" "$INIT_SCRIPT_PATH"

    echo -e "${YELLOW}Création de l'environnement virtuel global...${NC}"
    sleep 0.1
    python3 -m venv "$VENV_DIR"
    echo -e "${YELLOW}Installation de Pwntools...${NC}"
    sleep 0.7
    "$VENV_DIR/bin/pip" install -q pwntools > /dev/null 2>&1
    echo -e "${GREEN}Environnement PwnEnv prêt !${NC}"
    sleep 0.5
}

# ==============================================================================
# LOGIQUE PRINCIPALE
# ==============================================================================
mkdir -p "$CHALLENGES_DIR"
COMMAND=$1; shift
self_setup
source "$VENV_DIR/bin/activate"
export PYTHONPATH="$PYTHONPATH:$TOOLS_DIR"

case $COMMAND in
    init)
        echo -e "${BOLD}${GREEN}PwnEnv - v${PWNENV_VERSION} - Just make Pwn${NC}"
        PROJECT_NAME=$1
        if [ -z "$PROJECT_NAME" ]; then echo -e "${RED}Erreur: 'init' requiert un nom de projet.${NC}"; show_help; exit 1; fi
        PROJECT_PATH="$CHALLENGES_DIR/$PROJECT_NAME"
        shift
        
        # Analyse avancée des arguments
        local_binary_path=""
        ssh_remote_spec=""
        declare -A ssh_args
        libc_spec=""
        while (( "$#" )); do
            case "$1" in
                --local)
                    local_binary_path="$2"; shift 2;;
                --ssh)
                    ssh_remote_spec="$2"; shift 2;;
                --ssh-host|--ssh-user|--ssh-port|--ssh-pass|--ssh-bin|--ssh-src|--ssh-password)
                    key="${1#--ssh-}"
                    if [[ "$key" == "password" ]]; then key="pass"; fi
                    ssh_args[$key]="$2"; shift 2;;
                --libc)
                    libc_spec="$2"; shift 2;;
                *) echo -e "${RED}Option inconnue: $1${NC}"; show_help; exit 1;;
            esac
        done
        
        echo -e "${CYAN}Initialisation du repertoire '$PROJECT_NAME'...${NC}"
        
        CMD_ARGS=("$PROJECT_PATH")

        if [[ -n "$local_binary_path" ]]; then
            echo "Source: Binaire local ($local_binary_path)"
            CMD_ARGS+=("--binary-path" "$local_binary_path")
        fi

        if [[ -n "$ssh_remote_spec" ]]; then
            echo "Source: SSH ($ssh_remote_spec)"
            remote_path="${ssh_remote_spec#*:}"
            if [[ "$remote_path" == "$ssh_remote_spec" ]]; then
                echo -e "${RED}Erreur: format attendu 'user@hote:/chemin' pour --ssh.${NC}"
                exit 1
            fi
            if [[ -z "${ssh_args[bin]}" ]]; then
                ssh_args[bin]="$remote_path"
            fi
            remote_user_host="${ssh_remote_spec%%:*}"
            if [[ "$remote_user_host" == *"@"* ]]; then
                user_part="${remote_user_host%@*}"
                host_part="${remote_user_host#*@}"
                if [[ -z "${ssh_args[user]}" ]]; then
                    ssh_args[user]="$user_part"
                fi
                if [[ -z "${ssh_args[host]}" ]]; then
                    ssh_args[host]="$host_part"
                fi
            else
                if [[ -z "${ssh_args[host]}" ]]; then
                    ssh_args[host]="$remote_user_host"
                fi
            fi
        fi

        if [[ -n "${ssh_args[host]}" && -n "${ssh_args[user]}" && -z "${ssh_args[pass]}" ]]; then
            read -s -p "Mot de passe SSH pour ${ssh_args[user]}@${ssh_args[host]}: " ssh_password_input
            echo
            ssh_args[pass]="$ssh_password_input"
        fi

        if [[ -n "${ssh_args[src]}" ]]; then
            echo "Source distante référencée: ${ssh_args[src]}"
        fi

        if [[ -n "${ssh_args[host]}" ]]; then CMD_ARGS+=("--ssh-host" "${ssh_args[host]}"); fi
        if [[ -n "${ssh_args[user]}" ]]; then CMD_ARGS+=("--ssh-user" "${ssh_args[user]}"); fi
        if [[ -n "${ssh_args[port]}" ]]; then CMD_ARGS+=("--ssh-port" "${ssh_args[port]}"); fi
        if [[ -n "${ssh_args[pass]}" ]]; then CMD_ARGS+=("--ssh-pass" "${ssh_args[pass]}"); fi
        if [[ -n "${ssh_args[bin]}" ]]; then CMD_ARGS+=("--ssh-bin" "${ssh_args[bin]}"); fi
        if [[ -n "${ssh_args[src]}" ]]; then CMD_ARGS+=("--ssh-src" "${ssh_args[src]}"); fi
        if [[ -n "$libc_spec" ]]; then
            echo "Libc spécifiée: $libc_spec"
            CMD_ARGS+=("--libc" "$libc_spec")
        fi

        python3 "$INIT_SCRIPT_PATH" "${CMD_ARGS[@]}"
        
        if [ $? -ne 0 ]; then echo -e "${RED}L'initialisation a échoué.${NC}"; exit 1; fi

        echo -e "\n${GREEN}Projet initialisé. Activation de l'environnement...${NC}"
        cd "$PROJECT_PATH"
        # Activer le venv global pour disposer des librairies immédiatement
        source "$VENV_DIR/bin/activate"
        exec "$SHELL"
        ;;
    go)
        echo -e "${BOLD}${GREEN}PwnEnv - v${PWNENV_VERSION} - Just make Pwn${NC}"
        PROJECT_NAME=$1
        if [ -z "$PROJECT_NAME" ]; then echo -e "${RED}Erreur: 'go' requiert un nom de projet.${NC}"; show_help; exit 1; fi
        PROJECT_PATH="$CHALLENGES_DIR/$PROJECT_NAME"
        if [ ! -d "$PROJECT_PATH" ]; then echo -e "${RED}Erreur: Le projet '$PROJECT_NAME' n'existe pas.${NC}"; exit 1; fi
        cd "$PROJECT_PATH"
        echo -e "${GREEN}Déplacement vers '$PROJECT_NAME'... (environnement déjà actif)${NC}"
        exec "$SHELL"
        ;;

    *)
        show_help; exit 1;
        ;;
esac