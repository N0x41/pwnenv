#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import shutil
import stat
import subprocess
import sys
from getpass import getpass
from pathlib import Path

PWNENV_VERSION = "3.2.1"
CONFIG_PATH = Path.home() / ".local" / "share" / "pwnenv.json"
DEFAULT_CONFIG = {
    "challenges_dir": str(Path.home() / "challenges"),
}

BOLD = "\033[1m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
RED = "\033[0;31m"
CYAN = "\033[0;36m"
NC = "\033[0m"


def colorize(color: str, text: str) -> str:
    return f"{color}{text}{NC}"


EXPLOIT_PY_FALLBACK = (
    "#!/usr/bin/env python3\n"
    "print('Template pwnenv fallback. Utilisez \"pwn template\" pour un squelette complet.')\n"
)


def load_config() -> dict:
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text())
        except Exception:
            data = DEFAULT_CONFIG.copy()
        changed = False
        for key, value in DEFAULT_CONFIG.items():
            if key not in data:
                data[key] = value
                changed = True
        if changed:
            CONFIG_PATH.write_text(json.dumps(data, indent=4))
        return data
    CONFIG_PATH.write_text(json.dumps(DEFAULT_CONFIG, indent=4))
    return DEFAULT_CONFIG.copy()


def expand_path(path_str: str) -> Path:
    return Path(os.path.expanduser(path_str)).resolve()


class Paths:
    def __init__(self, config: dict):
        self.challenges_dir = expand_path(config["challenges_dir"])
        self.venv_dir = self.challenges_dir / ".pwnenv"
        self.tools_dir = self.venv_dir / "tools"
        self.script_dir = Path(__file__).resolve().parent
        self.api_script = self.tools_dir / "pwnapi.py"
        self.venv_python = self.venv_dir / "bin" / "python"
        self.venv_pip = self.venv_dir / "bin" / "pip"
        self.tmux_default_config = self.script_dir / "tools" / "tmux.config"
        tmux_env = os.environ.get("PWNENV_TMUX_CONFIG")
        self.tmux_config = (
            expand_path(tmux_env) if tmux_env else self.tools_dir / "tmux.config"
        )


def print_header() -> None:
    print(colorize(GREEN, f"{BOLD}PwnEnv - v{PWNENV_VERSION} - Just make Pwn{NC}"))


def show_help() -> None:
    print_header()
    print("Usage: pwnenv <commande> [arguments]")
    print(f"\n  {colorize(CYAN, 'init')} <nom_projet> [source] [options_ssh]   Initialise un challenge.")
    print(f"  {colorize(CYAN, 'go')}   <nom_projet>                          Se déplace dans un projet et active l'environnement.")
    print("\n" + colorize(BOLD, "SOURCES POUR 'init' :"))
    print(f"  {colorize(YELLOW, '--local')} /chemin/binaire       Utilise un binaire local.")
    print(f"  {colorize(YELLOW, '--ssh')} user@host:/path/bin     Référence un binaire distant.")
    print("  (aucune source)               Crée un projet vide.")
    print("\n" + colorize(BOLD, "OPTIONS SSH POUR 'init' (sauvegardées pour l'exploit) :"))
    print(f"  {colorize(YELLOW, '--ssh-host')} <host>             Nom d'hôte pour l'exécution distante.")
    print(f"  {colorize(YELLOW, '--ssh-user')} <user>             Utilisateur pour l'exécution distante.")
    print(f"  {colorize(YELLOW, '--ssh-port')} <port>             Port SSH.")
    print(f"  {colorize(YELLOW, '--ssh-pass')} <mdp>              Mot de passe SSH.")
    print(f"  {colorize(YELLOW, '--libc')} <chemin|version>       Spécifie la libc à utiliser.")


def run(cmd: list[str], **kwargs) -> None:
    subprocess.run(cmd, check=True, **kwargs)


def self_setup(paths: Paths) -> None:
    paths.tools_dir.mkdir(parents=True, exist_ok=True)
    source_dir_env = os.environ.get("PWNENV_TOOLS_PATH")
    if source_dir_env:
        source_dir = Path(source_dir_env).expanduser().resolve()
    else:
        source_dir = paths.script_dir / "tools"
    required = source_dir / "pwnapi.py"
    if not required.exists():
        print(colorize(RED, f"Erreur: Scripts introuvables dans '{source_dir}'."))
        sys.exit(1)
    if required.resolve() != paths.api_script.resolve():
        shutil.copy2(required, paths.api_script)
    legacy_api = paths.tools_dir / "pwnlib_api.py"
    if legacy_api.exists():
        try:
            legacy_api.unlink()
        except OSError:
            pass
    template_src = source_dir / "pwnenv.mako"
    if template_src.exists():
        dest_template = paths.tools_dir / "pwnenv.mako"
        if template_src.resolve() != dest_template.resolve():
            shutil.copy2(template_src, dest_template)
    tmux_config_src = source_dir / "tmux.config"
    if tmux_config_src.exists():
        shutil.copy2(tmux_config_src, paths.tools_dir / "tmux.config")
    tmux_sidebar_src = source_dir / "tmux-sidebar"
    if tmux_sidebar_src.is_dir():
        shutil.copytree(tmux_sidebar_src, paths.tools_dir / "tmux-sidebar", dirs_exist_ok=True)
    if paths.venv_dir.exists():
        return
    print(colorize(YELLOW, "Première utilisation. Configuration de l'environnement global..."))
    # The following operations are integration-level and not unit-test friendly
    print(colorize(YELLOW, "Création de l'environnement virtuel global..."))  # pragma: no cover
    paths.challenges_dir.mkdir(parents=True, exist_ok=True)  # pragma: no cover
    run([sys.executable, "-m", "venv", str(paths.venv_dir)])  # pragma: no cover
    print(colorize(YELLOW, "Installation de Pwntools..."))  # pragma: no cover
    run([str(paths.venv_pip), "install", "pwntools"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)  # pragma: no cover
    print(colorize(GREEN, "Environnement PwnEnv prêt !"))  # pragma: no cover


def ensure_password(ssh_opts: dict) -> None:
    if ssh_opts.get("host") and ssh_opts.get("user") and not ssh_opts.get("pass"):
        ssh_opts["pass"] = getpass(f"Mot de passe SSH pour {ssh_opts['user']}@{ssh_opts['host']}: ")


def handle_init(args: argparse.Namespace, paths: Paths) -> None:
    if not args.project_name:
        print(colorize(RED, "Erreur: 'init' requiert un nom de projet."))
        show_help()
        sys.exit(1)
    project_path = paths.challenges_dir / args.project_name
    if project_path.exists():
        print(colorize(RED, f"Erreur: '{project_path}' existe déjà."))
        sys.exit(1)

    local_binary = Path(args.local).expanduser() if args.local else None
    if local_binary and not local_binary.exists():
        print(colorize(RED, f"Erreur: binaire local introuvable '{local_binary}'."))
        sys.exit(1)

    source_candidate_str = args.source_path_option or args.source_path
    source_candidate = (
        Path(source_candidate_str).expanduser() if source_candidate_str else None
    )
    if source_candidate and not source_candidate.exists():
        print(colorize(RED, f"Erreur: la source '{source_candidate}' est introuvable."))
        sys.exit(1)

    project_path.mkdir(parents=True)
    src_dir = project_path / "src"
    src_dir.mkdir(exist_ok=True)
    bin_dir = project_path / "bin"

    binary_name = None
    if local_binary:
        print(f"Source: Binaire local ({local_binary})")
        bin_dir.mkdir(exist_ok=True)
        binary_name = local_binary.name
        dest_binary = bin_dir / binary_name
        shutil.copy2(local_binary, dest_binary)
        dest_binary.chmod(dest_binary.stat().st_mode | stat.S_IEXEC)

    ssh_opts: dict[str, str | int] = {}
    remote_spec = args.ssh
    if remote_spec:
        print(f"Source: SSH ({remote_spec})")
        if ":" not in remote_spec:
            print(colorize(RED, "Erreur: format attendu 'user@hote:/chemin' pour --ssh."))
            sys.exit(1)
        user_host, remote_path = remote_spec.split(":", 1)
        ssh_opts.setdefault("bin", remote_path)
        if "@" in user_host:
            user, host = user_host.split("@", 1)
            ssh_opts.setdefault("user", user)
            ssh_opts.setdefault("host", host)
        else:
            ssh_opts.setdefault("host", user_host)
    for attr, key in (
        ("ssh_host", "host"),
        ("ssh_user", "user"),
        ("ssh_port", "port"),
        ("ssh_pass", "pass"),
        ("ssh_bin", "bin"),
        ("ssh_src", "src"),
    ):
        value = getattr(args, attr)
        if value:
            ssh_opts[key] = value
    ensure_password(ssh_opts)
    if ssh_opts.get("src"):
        print(f"Source distante référencée: {ssh_opts['src']}")

    libc_config: dict[str, str] = {}
    libc_template_value = None
    if args.libc:
        print(f"Libc spécifiée: {args.libc}")
        libc_candidate = Path(args.libc).expanduser()
        if libc_candidate.exists():
            if libc_candidate.is_dir():
                print(colorize(RED, "Erreur: --libc doit pointer vers un fichier, pas un dossier."))
                sys.exit(1)
            lib_dir = project_path / "lib"
            lib_dir.mkdir(exist_ok=True)
            dest_libc = lib_dir / libc_candidate.name
            shutil.copy2(libc_candidate, dest_libc)
            libc_config["local"] = f"./lib/{dest_libc.name}"
            libc_template_value = str(dest_libc)
        else:
            libc_config["version"] = args.libc
            libc_template_value = args.libc

    ssh_config = {k: v for k, v in ssh_opts.items() if v is not None}
    config = {
        "binary_path_local": f"./bin/{binary_name}" if binary_name else None,
        "ssh": ssh_config,
    }
    if libc_config:
        config["libc"] = libc_config

    with (project_path / "pwnenv.conf.json").open("w") as f:
        json.dump(config, f, indent=4)

    if source_candidate:
        if source_candidate.is_dir():
            dest_folder = src_dir / source_candidate.name
            shutil.copytree(source_candidate, dest_folder, dirs_exist_ok=True)
        else:
            dest_source = src_dir / source_candidate.name
            shutil.copy2(source_candidate, dest_source)

    exploit_script_path = project_path / "exploit.py"
    template_candidates = [
        paths.tools_dir / "pwnenv.mako",
        paths.script_dir / "tools" / "pwnenv.mako",
    ]
    template_path = next((candidate for candidate in template_candidates if candidate.exists()), None)
    template_cmd = ["pwn", "template"]
    if template_path:
        template_cmd += ["--template", str(template_path)]
    if binary_name:
        template_cmd.append(f"./bin/{binary_name}")
    else:
        if ssh_opts.get("host"):
            template_cmd += ["--host", str(ssh_opts["host"])]
        if ssh_opts.get("port"):
            template_cmd += ["--port", str(ssh_opts["port"])]
        if ssh_opts.get("user"):
            template_cmd += ["--user", str(ssh_opts["user"])]
        if ssh_opts.get("pass"):
            template_cmd += ["--pass", str(ssh_opts["pass"])]
        if ssh_opts.get("bin"):
            template_cmd += ["--path", str(ssh_opts["bin"])]
    if libc_template_value:
        template_cmd += ["--libc", str(libc_template_value)]

    try:
        tpl = subprocess.run(template_cmd, check=True, capture_output=True, text=True)
        exploit_script_path.write_text(tpl.stdout)
    except Exception:
        exploit_script_path.write_text(EXPLOIT_PY_FALLBACK)
    exploit_script_path.chmod(0o755)

    print(f"✅ Structure du projet '{project_path.name}' créée.")
    print(colorize(GREEN, "\nProjet initialisé. Activation de l'environnement..."))
    exec_shell(project_path, paths, args.project_name)


def exec_shell(target_dir: Path, paths: Paths, project_name: str | None) -> None:
    shell = os.environ.get("SHELL", "/bin/bash")
    env = os.environ.copy()
    env["VIRTUAL_ENV"] = str(paths.venv_dir)
    bin_dir = str(paths.venv_dir / "bin")
    env["PATH"] = f"{bin_dir}:{env.get('PATH', '')}"
    python_path = env.get("PYTHONPATH")
    if python_path:
        env["PYTHONPATH"] = f"{python_path}:{paths.tools_dir}"
    else:
        env["PYTHONPATH"] = str(paths.tools_dir)
    env["PWD"] = str(target_dir)
    env["PWNENV_TOOLS_DIR"] = str(paths.tools_dir)
    os.chdir(target_dir)
    if os.environ.get("TMUX"):
        os.execve(shell, [shell], env)
    tmux_path = shutil.which("tmux")
    if not tmux_path:
        print(colorize(YELLOW, "tmux introuvable ; lancement du shell standard."))
        os.execve(shell, [shell], env)
    safe_name = (project_name or "pwnenv").replace(" ", "_")
    session_name = f"{safe_name}"
    tmux_candidates = []
    tmux_env = os.environ.get("PWNENV_TMUX_CONFIG")
    if tmux_env:
        tmux_candidates.append(expand_path(tmux_env))
    tmux_candidates.append(paths.tmux_config)
    tmux_candidates.append(paths.tmux_default_config)
    tmux_config = next((candidate for candidate in tmux_candidates if candidate and candidate.exists()), None)
    if tmux_config:
        has_session = subprocess.run(
            [tmux_path, "has-session", "-t", session_name],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        if has_session.returncode == 0:
            subprocess.run(
                [tmux_path, "source-file", str(tmux_config)],
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
    cmd = [tmux_path]
    if tmux_config:
        cmd.extend(["-f", str(tmux_config)])
    cmd.extend(["new-session", "-As", session_name, "-c", str(target_dir), shell])
    os.execve(tmux_path, cmd, env)


def handle_go(args: argparse.Namespace, paths: Paths) -> None:
    if not args.project_name:
        print(colorize(RED, "Erreur: 'go' requiert un nom de projet."))
        show_help()
        sys.exit(1)
    project_path = paths.challenges_dir / args.project_name
    if not project_path.is_dir():
        print(colorize(RED, f"Erreur: Le projet '{args.project_name}' n'existe pas."))
        sys.exit(1)
    print(colorize(GREEN, f"Déplacement vers '{args.project_name}'... (environnement déjà actif)"))
    exec_shell(project_path, paths, args.project_name)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="pwnenv", add_help=False)
    subparsers = parser.add_subparsers(dest="command")

    init_parser = subparsers.add_parser("init", add_help=False)
    init_parser.add_argument("project_name", nargs="?")
    init_parser.add_argument("source_path", nargs="?")
    init_parser.add_argument("--local")
    init_parser.add_argument("--ssh")
    init_parser.add_argument("--ssh-host")
    init_parser.add_argument("--ssh-user")
    init_parser.add_argument("--ssh-port", type=int)
    init_parser.add_argument("--ssh-pass", dest="ssh_pass")
    init_parser.add_argument("--ssh-password", dest="ssh_pass")
    init_parser.add_argument("--ssh-bin")
    init_parser.add_argument("--ssh-src")
    init_parser.add_argument("--libc")
    init_parser.add_argument("--source-path", dest="source_path_option")

    go_parser = subparsers.add_parser("go", add_help=False)
    go_parser.add_argument("project_name", nargs="?")

    parser.add_argument("-h", "--help", action="store_true")
    return parser


def main() -> None:
    config = load_config()
    paths = Paths(config)
    paths.challenges_dir.mkdir(parents=True, exist_ok=True)
    self_setup(paths)

    parser = build_parser()
    args, unknown = parser.parse_known_args()
    if args.help or not args.command:
        show_help()
        return
    if unknown:
        if any(flag in unknown for flag in ("-h", "--help")):
            show_help()
            return
        print(colorize(RED, f"Options inconnues: {' '.join(unknown)}"))
        sys.exit(1)
    print_header()
    if args.command == "init":
        handle_init(args, paths)
    elif args.command == "go":
        handle_go(args, paths)
    else:
        show_help()
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()  # pragma: no cover
        sys.exit(1)  # pragma: no cover